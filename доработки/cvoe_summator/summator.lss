
summator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  000006ec  00000780  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001d  00800106  00800106  00000786  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00000786  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000021f  00000000  00000000  00000846  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000871  00000000  00000000  00000a65  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000479  00000000  00000000  000012d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000826  00000000  00000000  0000174f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000180  00000000  00000000  00001f78  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001b9  00000000  00000000  000020f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000143  00000000  00000000  000022b1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	44 c2       	rjmp	.+1160   	; 0x48c <__vector_1>
   4:	12 c2       	rjmp	.+1060   	; 0x42a <__vector_2>
   6:	7e c2       	rjmp	.+1276   	; 0x504 <__vector_3>
   8:	c8 c2       	rjmp	.+1424   	; 0x59a <__vector_4>
   a:	14 c3       	rjmp	.+1576   	; 0x634 <__vector_5>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	dd c1       	rjmp	.+954    	; 0x3ca <__vector_7>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	29 c0       	rjmp	.+82     	; 0x6a <__bad_interrupt>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	cd c0       	rjmp	.+410    	; 0x1c0 <__vector_18>
  26:	42 c1       	rjmp	.+644    	; 0x2ac <__vector_19>
  28:	6d c1       	rjmp	.+730    	; 0x304 <__vector_20>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d2 e0       	ldi	r29, 0x02	; 2
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	ec ee       	ldi	r30, 0xEC	; 236
  48:	f6 e0       	ldi	r31, 0x06	; 6
  4a:	02 c0       	rjmp	.+4      	; 0x50 <.do_copy_data_start>

0000004c <.do_copy_data_loop>:
  4c:	05 90       	lpm	r0, Z+
  4e:	0d 92       	st	X+, r0

00000050 <.do_copy_data_start>:
  50:	a6 30       	cpi	r26, 0x06	; 6
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <.do_copy_data_loop>

00000056 <__do_clear_bss>:
  56:	11 e0       	ldi	r17, 0x01	; 1
  58:	a6 e0       	ldi	r26, 0x06	; 6
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	a3 32       	cpi	r26, 0x23	; 35
  62:	b1 07       	cpc	r27, r17
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
  66:	02 d0       	rcall	.+4      	; 0x6c <main>
  68:	3f c3       	rjmp	.+1662   	; 0x6e8 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <main>:
//***********************************************************************
extern unsigned int crc16_modbus( unsigned char *buf,unsigned char len);
extern void crc16_modbus1(unsigned int *crc, unsigned char dat);
//********************************************************************
int main(void)
{
  6c:	1f 93       	push	r17
	init_pr();		// начальная настройка портов и таймеров
  6e:	39 d0       	rcall	.+114    	; 0xe2 <init_pr>
    Init_uart(); 	// Настраиваем приемник.
  70:	7b d0       	rcall	.+246    	; 0x168 <Init_uart>
	Enable_RX();  	//разрешаем прием
  72:	9a d0       	rcall	.+308    	; 0x1a8 <Enable_RX>
	sei(); 			// разрешаем прерывания.
  74:	78 94       	sei
					break;
				}
				case 0x99: //игра пассивными ракетками
				{
				// делаем начальную установку параметров
					EIMSK=(1<<INT0); //включаем нулевой датчик
  76:	11 e0       	ldi	r17, 0x01	; 1
	Enable_RX();  	//разрешаем прием
	sei(); 			// разрешаем прерывания.
	while (1) 		// бесконечный цикл. основной цикл программы.
	{
	
		if(flag.rx_ok)
  78:	90 91 06 01 	lds	r25, 0x0106
  7c:	91 ff       	sbrs	r25, 1
  7e:	30 c0       	rjmp	.+96     	; 0xe0 <main+0x74>
		{
			code=Buf_ok[0];         // устанавливаем тип игры
  80:	80 91 09 01 	lds	r24, 0x0109
  84:	80 93 00 01 	sts	0x0100, r24
			time_d=Buf_ok[1];		// время антидребезга
  88:	40 91 0a 01 	lds	r20, 0x010A
			time_t=Buf_ok[2];		// темп игры
  8c:	30 91 0b 01 	lds	r19, 0x010B
			time_p=Buf_ok[3];		// время паузы
  90:	20 91 0c 01 	lds	r18, 0x010C
			flag.rx_ok=0; 			//сбрасываем флаг приема пакета
  94:	9d 7f       	andi	r25, 0xFD	; 253
  96:	90 93 06 01 	sts	0x0106, r25
			PCICR=0;                //запрещаем прерывания по изменению.
  9a:	10 92 68 00 	sts	0x0068, r1
			PCIFR=0;				// сбрасываем флаги
  9e:	1b ba       	out	0x1b, r1	; 27
			EIMSK=0;				// отключаем прерывания по 0 датчику
  a0:	1d ba       	out	0x1d, r1	; 29
			EIFR=0;					//сбрасываем флаги
  a2:	1c ba       	out	0x1c, r1	; 28
			switch (code) 			// настраиваем начальные значения прерываний.
  a4:	80 91 00 01 	lds	r24, 0x0100
  a8:	83 33       	cpi	r24, 0x33	; 51
  aa:	19 f0       	breq	.+6      	; 0xb2 <main+0x46>
  ac:	89 39       	cpi	r24, 0x99	; 153
  ae:	21 f7       	brne	.-56     	; 0x78 <main+0xc>
  b0:	0a c0       	rjmp	.+20     	; 0xc6 <main+0x5a>
  b2:	20 93 04 01 	sts	0x0104, r18
  b6:	30 93 02 01 	sts	0x0102, r19
  ba:	10 92 03 01 	sts	0x0103, r1
  be:	40 93 01 01 	sts	0x0101, r20
			{
				case 0x33:
				{
					// начальная установка игра пинг понг и теста датчиков.
					Init_dat_r33();
  c2:	33 d0       	rcall	.+102    	; 0x12a <Init_dat_r33>
  c4:	d9 cf       	rjmp	.-78     	; 0x78 <main+0xc>
					break;
  c6:	20 93 04 01 	sts	0x0104, r18
  ca:	30 93 02 01 	sts	0x0102, r19
  ce:	10 92 03 01 	sts	0x0103, r1
  d2:	40 93 01 01 	sts	0x0101, r20
					break;
				}
				case 0x99: //игра пассивными ракетками
				{
				// делаем начальную установку параметров
					EIMSK=(1<<INT0); //включаем нулевой датчик
  d6:	1d bb       	out	0x1d, r17	; 29
					EIFR=0;
  d8:	1c ba       	out	0x1c, r1	; 28
					Buf_out[0]=0x99;
  da:	80 93 0d 01 	sts	0x010D, r24
  de:	cc cf       	rjmp	.-104    	; 0x78 <main+0xc>
  e0:	ff cf       	rjmp	.-2      	; 0xe0 <main+0x74>

000000e2 <init_pr>:
void Init_dat_r33(void); // настройка прерываний на работу в режиме теста
//*************************************************************************
void init_pr(void)
{
	// настройка портов
	DDRB=0x010;
  e2:	80 e1       	ldi	r24, 0x10	; 16
  e4:	84 b9       	out	0x04, r24	; 4
	DDRC=0;  			// порт на ввод
  e6:	17 b8       	out	0x07, r1	; 7
	DDRD=0;  			// порт на ввод
  e8:	1a b8       	out	0x0a, r1	; 10
	// устанавливаем порты
	PORTB=0xEF; 
  ea:	8f ee       	ldi	r24, 0xEF	; 239
  ec:	85 b9       	out	0x05, r24	; 5
	PORTC=0xff;
  ee:	8f ef       	ldi	r24, 0xFF	; 255
  f0:	88 b9       	out	0x08, r24	; 8
	PORTD=0xff;
  f2:	8b b9       	out	0x0b, r24	; 11
	PRR=0x85;    		//Отключить модули TWI,SPI,АЦП
  f4:	85 e8       	ldi	r24, 0x85	; 133
  f6:	80 93 64 00 	sts	0x0064, r24
	// настраиваем таймер 1
	TCCR1A=0;	    	//	Настройка таймера Т1 с периодом вызова
  fa:	10 92 80 00 	sts	0x0080, r1
	TCCR1C=0;	    	//	прерываний по совпадению A 16,0 сек 
  fe:	10 92 82 00 	sts	0x0082, r1
	OCR1AH=0xf4;	    //	Регистр совпадения А таймера/счётчика Т1 ст. байт
 102:	84 ef       	ldi	r24, 0xF4	; 244
 104:	80 93 89 00 	sts	0x0089, r24
	OCR1AL=0x23;	    //	Регистр совпадения А таймера/счётчика Т1 мл. байт
 108:	83 e2       	ldi	r24, 0x23	; 35
 10a:	80 93 88 00 	sts	0x0088, r24
	TCCR1B=0x0d;	    //	Пуск таймера/счётчика Т1   
 10e:	8d e0       	ldi	r24, 0x0D	; 13
 110:	80 93 81 00 	sts	0x0081, r24
	//Инициализация таймера Т2 
	TCCR2A=0x02;		//Настройка таймера Т2 с периодом вызова
 114:	82 e0       	ldi	r24, 0x02	; 2
 116:	80 93 b0 00 	sts	0x00B0, r24
	OCR2A=0xc3;			//прерываний по совпадению A 50,0 мс	
 11a:	83 ec       	ldi	r24, 0xC3	; 195
 11c:	80 93 b3 00 	sts	0x00B3, r24
	// настройка прерываний по выводам.
	EICRA=(1<<ISC01)|(1<<ISC11); // Прерывание от INT0,INT1 по спаду
 120:	8a e0       	ldi	r24, 0x0A	; 10
 122:	80 93 69 00 	sts	0x0069, r24
	Init_dat_r33();
 126:	01 d0       	rcall	.+2      	; 0x12a <Init_dat_r33>
}
 128:	08 95       	ret

0000012a <Init_dat_r33>:

void Init_dat_r33(void) // настройка прерываний на работу в режиме теста
{
	code=0x33;
 12a:	23 e3       	ldi	r18, 0x33	; 51
 12c:	20 93 00 01 	sts	0x0100, r18
	EIMSK=(1<<INT0)|(1<<INT1);
 130:	93 e0       	ldi	r25, 0x03	; 3
 132:	9d bb       	out	0x1d, r25	; 29
	EIFR=0;	
 134:	1c ba       	out	0x1c, r1	; 28
	PCMSK2=(1<<PCINT23);
 136:	80 e8       	ldi	r24, 0x80	; 128
 138:	80 93 6d 00 	sts	0x006D, r24
	PCMSK1=(1<<PCINT11);
 13c:	88 e0       	ldi	r24, 0x08	; 8
 13e:	80 93 6c 00 	sts	0x006C, r24
	PCMSK0=(1<<PCINT3);
 142:	80 93 6b 00 	sts	0x006B, r24
	PCICR=(1<<PCIE2)|(1<<PCIE1)|(1<<PCIE0);
 146:	87 e0       	ldi	r24, 0x07	; 7
 148:	80 93 68 00 	sts	0x0068, r24
	PCIFR=0;	
 14c:	1b ba       	out	0x1b, r1	; 27
	TCCR2B=0;		    //Стоп таймера/счётчика Т2
 14e:	10 92 b1 00 	sts	0x00B1, r1
	Buf_out[0]=0x33;
 152:	20 93 0d 01 	sts	0x010D, r18
	Buf_out[1]=0x03;
 156:	90 93 0e 01 	sts	0x010E, r25
	Buf_out[3]=0;
 15a:	10 92 10 01 	sts	0x0110, r1
	Buf_out[4]=0;
 15e:	10 92 11 01 	sts	0x0111, r1
	w_cont=7;
 162:	80 93 15 01 	sts	0x0115, r24
}
 166:	08 95       	ret

00000168 <Init_uart>:
volatile unsigned char Buf_ok[4];
//**********************************************************************

void Init_uart(void)
{
UBRR0H=0x00;		//Скорость 9600
 168:	10 92 c5 00 	sts	0x00C5, r1
UBRR0L=0x19;
 16c:	89 e1       	ldi	r24, 0x19	; 25
 16e:	80 93 c4 00 	sts	0x00C4, r24
UCSR0A=0x40; //очистить буфер
 172:	80 e4       	ldi	r24, 0x40	; 64
 174:	80 93 c0 00 	sts	0x00C0, r24
UCSR0C=(1<<USBS0)|(3<<UCSZ00); //8 - бит данных, один стоп бит
 178:	8e e0       	ldi	r24, 0x0E	; 14
 17a:	80 93 c2 00 	sts	0x00C2, r24
rr=0;
 17e:	10 92 1f 01 	sts	0x011F, r1
ww=0;
 182:	10 92 1e 01 	sts	0x011E, r1
crc.crc16=0xffff;
 186:	8f ef       	ldi	r24, 0xFF	; 255
 188:	9f ef       	ldi	r25, 0xFF	; 255
 18a:	90 93 08 01 	sts	0x0108, r25
 18e:	80 93 07 01 	sts	0x0107, r24
w_cont=0;
 192:	10 92 15 01 	sts	0x0115, r1
}
 196:	08 95       	ret

00000198 <Enable_TX>:
//************************************************************************
void Enable_TX(void)
{
	UCSR0B|=(1<<TXEN0)|(1<<UDRIE0)|(1<<TXCIE0);
 198:	e1 ec       	ldi	r30, 0xC1	; 193
 19a:	f0 e0       	ldi	r31, 0x00	; 0
 19c:	80 81       	ld	r24, Z
 19e:	88 66       	ori	r24, 0x68	; 104
 1a0:	80 83       	st	Z, r24
	ww=0;
 1a2:	10 92 1e 01 	sts	0x011E, r1
}
 1a6:	08 95       	ret

000001a8 <Enable_RX>:
//************************************************************************
void Enable_RX(void)
{
	UCSR0B|=(1<<RXEN0)|(1<<RXCIE0);
 1a8:	e1 ec       	ldi	r30, 0xC1	; 193
 1aa:	f0 e0       	ldi	r31, 0x00	; 0
 1ac:	80 81       	ld	r24, Z
 1ae:	80 69       	ori	r24, 0x90	; 144
 1b0:	80 83       	st	Z, r24
	crc.crc16=0xffff;
 1b2:	8f ef       	ldi	r24, 0xFF	; 255
 1b4:	9f ef       	ldi	r25, 0xFF	; 255
 1b6:	90 93 08 01 	sts	0x0108, r25
 1ba:	80 93 07 01 	sts	0x0107, r24
}
 1be:	08 95       	ret

000001c0 <__vector_18>:
//************************************************************************
ISR(USART_RX_vect) // прием закончен
{	
 1c0:	1f 92       	push	r1
 1c2:	0f 92       	push	r0
 1c4:	0f b6       	in	r0, 0x3f	; 63
 1c6:	0f 92       	push	r0
 1c8:	11 24       	eor	r1, r1
 1ca:	2f 93       	push	r18
 1cc:	3f 93       	push	r19
 1ce:	4f 93       	push	r20
 1d0:	5f 93       	push	r21
 1d2:	6f 93       	push	r22
 1d4:	7f 93       	push	r23
 1d6:	8f 93       	push	r24
 1d8:	9f 93       	push	r25
 1da:	af 93       	push	r26
 1dc:	bf 93       	push	r27
 1de:	ef 93       	push	r30
 1e0:	ff 93       	push	r31
	Buf_in[rr]=UDR0; // записываем принятые данные.
 1e2:	90 91 1f 01 	lds	r25, 0x011F
 1e6:	60 91 c6 00 	lds	r22, 0x00C6
 1ea:	e9 2f       	mov	r30, r25
 1ec:	f0 e0       	ldi	r31, 0x00	; 0
 1ee:	ea 5e       	subi	r30, 0xEA	; 234
 1f0:	fe 4f       	sbci	r31, 0xFE	; 254
 1f2:	60 83       	st	Z, r22
	if(Buf_in[0]!=0xCC) // ждем индефикатора
 1f4:	80 91 16 01 	lds	r24, 0x0116
 1f8:	8c 3c       	cpi	r24, 0xCC	; 204
 1fa:	59 f0       	breq	.+22     	; 0x212 <__vector_18+0x52>
	{
	// устанавливаем начальные значения
		crc.crc16=0xffff;
 1fc:	8f ef       	ldi	r24, 0xFF	; 255
 1fe:	9f ef       	ldi	r25, 0xFF	; 255
 200:	90 93 08 01 	sts	0x0108, r25
 204:	80 93 07 01 	sts	0x0107, r24
		rr=0;
 208:	10 92 1f 01 	sts	0x011F, r1
		Buf_in[0]=0x00;
 20c:	10 92 16 01 	sts	0x0116, r1
 210:	3c c0       	rjmp	.+120    	; 0x28a <__vector_18+0xca>
		return;
	}
	if(rr<=5) // принимаем пакет и считаем контрольную сумму
 212:	96 30       	cpi	r25, 0x06	; 6
 214:	18 f4       	brcc	.+6      	; 0x21c <__vector_18+0x5c>
	{
		crc16_modbus1((unsigned int *)&crc.crc16,(unsigned char)Buf_in[rr]);
 216:	87 e0       	ldi	r24, 0x07	; 7
 218:	91 e0       	ldi	r25, 0x01	; 1
 21a:	9a d0       	rcall	.+308    	; 0x350 <crc16_modbus1>
	}
	if(rr==7) // сверяем кс
 21c:	80 91 1f 01 	lds	r24, 0x011F
 220:	87 30       	cpi	r24, 0x07	; 7
 222:	81 f5       	brne	.+96     	; 0x284 <__vector_18+0xc4>
	{
		crc.crc8[0]^=Buf_in[7];
 224:	80 91 07 01 	lds	r24, 0x0107
 228:	90 91 1d 01 	lds	r25, 0x011D
 22c:	89 27       	eor	r24, r25
 22e:	80 93 07 01 	sts	0x0107, r24
		crc.crc8[1]^=Buf_in[6];
 232:	80 91 08 01 	lds	r24, 0x0108
 236:	90 91 1c 01 	lds	r25, 0x011C
 23a:	89 27       	eor	r24, r25
 23c:	80 93 08 01 	sts	0x0108, r24
		if(crc.crc16==0)
 240:	80 91 07 01 	lds	r24, 0x0107
 244:	90 91 08 01 	lds	r25, 0x0108
 248:	89 2b       	or	r24, r25
 24a:	71 f4       	brne	.+28     	; 0x268 <__vector_18+0xa8>
 24c:	a8 e1       	ldi	r26, 0x18	; 24
 24e:	b1 e0       	ldi	r27, 0x01	; 1
 250:	20 e0       	ldi	r18, 0x00	; 0
 252:	30 e0       	ldi	r19, 0x00	; 0
		{
			unsigned char i;
			for(i=0;i<=3; i++) Buf_ok[i]=Buf_in[i+2];
 254:	8d 91       	ld	r24, X+
 256:	f9 01       	movw	r30, r18
 258:	e7 5f       	subi	r30, 0xF7	; 247
 25a:	fe 4f       	sbci	r31, 0xFE	; 254
 25c:	80 83       	st	Z, r24
 25e:	2f 5f       	subi	r18, 0xFF	; 255
 260:	3f 4f       	sbci	r19, 0xFF	; 255
 262:	24 30       	cpi	r18, 0x04	; 4
 264:	31 05       	cpc	r19, r1
 266:	b1 f7       	brne	.-20     	; 0x254 <__vector_18+0x94>
		}
		flag.rx_ok=1; // устанавливаем флаг принятия пакета.
 268:	80 91 06 01 	lds	r24, 0x0106
 26c:	82 60       	ori	r24, 0x02	; 2
 26e:	80 93 06 01 	sts	0x0106, r24
		crc.crc16=0xffff; // устанавливаем начальные значения
 272:	8f ef       	ldi	r24, 0xFF	; 255
 274:	9f ef       	ldi	r25, 0xFF	; 255
 276:	90 93 08 01 	sts	0x0108, r25
 27a:	80 93 07 01 	sts	0x0107, r24
		rr=0;
 27e:	10 92 1f 01 	sts	0x011F, r1
 282:	03 c0       	rjmp	.+6      	; 0x28a <__vector_18+0xca>
		return;
	}
	rr++; // считаем количество принятых байт
 284:	8f 5f       	subi	r24, 0xFF	; 255
 286:	80 93 1f 01 	sts	0x011F, r24

}
 28a:	ff 91       	pop	r31
 28c:	ef 91       	pop	r30
 28e:	bf 91       	pop	r27
 290:	af 91       	pop	r26
 292:	9f 91       	pop	r25
 294:	8f 91       	pop	r24
 296:	7f 91       	pop	r23
 298:	6f 91       	pop	r22
 29a:	5f 91       	pop	r21
 29c:	4f 91       	pop	r20
 29e:	3f 91       	pop	r19
 2a0:	2f 91       	pop	r18
 2a2:	0f 90       	pop	r0
 2a4:	0f be       	out	0x3f, r0	; 63
 2a6:	0f 90       	pop	r0
 2a8:	1f 90       	pop	r1
 2aa:	18 95       	reti

000002ac <__vector_19>:
//************************************************************************
ISR(USART_UDRE_vect) // буфер данных пуст
{
 2ac:	1f 92       	push	r1
 2ae:	0f 92       	push	r0
 2b0:	0f b6       	in	r0, 0x3f	; 63
 2b2:	0f 92       	push	r0
 2b4:	11 24       	eor	r1, r1
 2b6:	8f 93       	push	r24
 2b8:	9f 93       	push	r25
 2ba:	ef 93       	push	r30
 2bc:	ff 93       	push	r31
	if(ww>=w_cont)
 2be:	90 91 1e 01 	lds	r25, 0x011E
 2c2:	80 91 15 01 	lds	r24, 0x0115
 2c6:	98 17       	cp	r25, r24
 2c8:	30 f0       	brcs	.+12     	; 0x2d6 <__vector_19+0x2a>
	{
		UCSR0B&=(0xfe<<UDRIE0); // отключаем прерывание по опустошению буфера. 
 2ca:	80 91 c1 00 	lds	r24, 0x00C1
 2ce:	80 7c       	andi	r24, 0xC0	; 192
 2d0:	80 93 c1 00 	sts	0x00C1, r24
 2d4:	0e c0       	rjmp	.+28     	; 0x2f2 <__vector_19+0x46>
		return;
	}
	UDR0=Buf_out[ww]; // передаем след байт.
 2d6:	e9 2f       	mov	r30, r25
 2d8:	f0 e0       	ldi	r31, 0x00	; 0
 2da:	e3 5f       	subi	r30, 0xF3	; 243
 2dc:	fe 4f       	sbci	r31, 0xFE	; 254
 2de:	80 81       	ld	r24, Z
 2e0:	80 93 c6 00 	sts	0x00C6, r24
	if(ww!=w_cont) ww++; //увеличиваем количество передаваем байт
 2e4:	80 91 15 01 	lds	r24, 0x0115
 2e8:	98 17       	cp	r25, r24
 2ea:	19 f0       	breq	.+6      	; 0x2f2 <__vector_19+0x46>
 2ec:	9f 5f       	subi	r25, 0xFF	; 255
 2ee:	90 93 1e 01 	sts	0x011E, r25
}
 2f2:	ff 91       	pop	r31
 2f4:	ef 91       	pop	r30
 2f6:	9f 91       	pop	r25
 2f8:	8f 91       	pop	r24
 2fa:	0f 90       	pop	r0
 2fc:	0f be       	out	0x3f, r0	; 63
 2fe:	0f 90       	pop	r0
 300:	1f 90       	pop	r1
 302:	18 95       	reti

00000304 <__vector_20>:
//*************************************************************************
ISR (USART_TX_vect) // передача завершена.
{
 304:	1f 92       	push	r1
 306:	0f 92       	push	r0
 308:	0f b6       	in	r0, 0x3f	; 63
 30a:	0f 92       	push	r0
 30c:	11 24       	eor	r1, r1
 30e:	8f 93       	push	r24
 310:	9f 93       	push	r25
 312:	ef 93       	push	r30
 314:	ff 93       	push	r31
	if(ww>=w_cont)
 316:	90 91 1e 01 	lds	r25, 0x011E
 31a:	80 91 15 01 	lds	r24, 0x0115
 31e:	98 17       	cp	r25, r24
 320:	70 f4       	brcc	.+28     	; 0x33e <__vector_20+0x3a>
	{	
		return; // все байты переданы
	}
	UDR0=Buf_out[ww]; // передаем след байт.
 322:	e9 2f       	mov	r30, r25
 324:	f0 e0       	ldi	r31, 0x00	; 0
 326:	e3 5f       	subi	r30, 0xF3	; 243
 328:	fe 4f       	sbci	r31, 0xFE	; 254
 32a:	80 81       	ld	r24, Z
 32c:	80 93 c6 00 	sts	0x00C6, r24
	if(ww!=w_cont)ww++; // увеличиваем количество передаваем байт
 330:	80 91 15 01 	lds	r24, 0x0115
 334:	98 17       	cp	r25, r24
 336:	19 f0       	breq	.+6      	; 0x33e <__vector_20+0x3a>
 338:	9f 5f       	subi	r25, 0xFF	; 255
 33a:	90 93 1e 01 	sts	0x011E, r25
}
 33e:	ff 91       	pop	r31
 340:	ef 91       	pop	r30
 342:	9f 91       	pop	r25
 344:	8f 91       	pop	r24
 346:	0f 90       	pop	r0
 348:	0f be       	out	0x3f, r0	; 63
 34a:	0f 90       	pop	r0
 34c:	1f 90       	pop	r1
 34e:	18 95       	reti

00000350 <crc16_modbus1>:
//***********************************************************************************
unsigned int crc16_modbus(unsigned char *dat,unsigned char len);
void crc16_modbus1(unsigned int *crc, unsigned char dat);
//**********************************************************************************
void crc16_modbus1(unsigned int *crc, unsigned char dat)
{
 350:	fc 01       	movw	r30, r24
	unsigned int temp;
	unsigned char i;
	temp=dat;
	temp&=0x00ff;
	*crc^=temp;
 352:	70 e0       	ldi	r23, 0x00	; 0
 354:	80 81       	ld	r24, Z
 356:	91 81       	ldd	r25, Z+1	; 0x01
 358:	68 27       	eor	r22, r24
 35a:	79 27       	eor	r23, r25
 35c:	20 e0       	ldi	r18, 0x00	; 0
	for (i=0; i<8; i++)
	{
		temp=*crc;
		*crc>>=1;
		if(temp & 0x0001) *crc^=0xa001;
 35e:	41 e0       	ldi	r20, 0x01	; 1
 360:	50 ea       	ldi	r21, 0xA0	; 160
	temp&=0x00ff;
	*crc^=temp;
	for (i=0; i<8; i++)
	{
		temp=*crc;
		*crc>>=1;
 362:	cb 01       	movw	r24, r22
 364:	96 95       	lsr	r25
 366:	87 95       	ror	r24
		if(temp & 0x0001) *crc^=0xa001;
 368:	60 fd       	sbrc	r22, 0
 36a:	02 c0       	rjmp	.+4      	; 0x370 <crc16_modbus1+0x20>
 36c:	bc 01       	movw	r22, r24
 36e:	03 c0       	rjmp	.+6      	; 0x376 <crc16_modbus1+0x26>
 370:	bc 01       	movw	r22, r24
 372:	64 27       	eor	r22, r20
 374:	75 27       	eor	r23, r21
	unsigned int temp;
	unsigned char i;
	temp=dat;
	temp&=0x00ff;
	*crc^=temp;
	for (i=0; i<8; i++)
 376:	2f 5f       	subi	r18, 0xFF	; 255
 378:	28 30       	cpi	r18, 0x08	; 8
 37a:	99 f7       	brne	.-26     	; 0x362 <crc16_modbus1+0x12>
 37c:	71 83       	std	Z+1, r23	; 0x01
 37e:	60 83       	st	Z, r22
	{
		temp=*crc;
		*crc>>=1;
		if(temp & 0x0001) *crc^=0xa001;
	}
}
 380:	08 95       	ret

00000382 <crc16_modbus>:
//**********************************************************************************
unsigned int crc16_modbus(unsigned char *buf,unsigned char len)
{
 382:	cf 93       	push	r28
 384:	df 93       	push	r29
 386:	dc 01       	movw	r26, r24
 388:	4f ef       	ldi	r20, 0xFF	; 255
 38a:	5f ef       	ldi	r21, 0xFF	; 255
 38c:	70 e0       	ldi	r23, 0x00	; 0
		crc ^=temp;
		for (i=0; i<8; i++)
		{
			temp=crc;
			crc>>=1;
			if(temp & 0x0001) crc^=0xa001;
 38e:	c1 e0       	ldi	r28, 0x01	; 1
 390:	d0 ea       	ldi	r29, 0xA0	; 160
{
	unsigned int crc=0xffff,temp;
	unsigned char pos,i;
	for (pos=0; pos<=len; pos++)
	{
		temp=buf[pos];
 392:	fd 01       	movw	r30, r26
 394:	e7 0f       	add	r30, r23
 396:	f1 1d       	adc	r31, r1
 398:	80 81       	ld	r24, Z
		temp&=0x00ff;
		crc ^=temp;
 39a:	28 2f       	mov	r18, r24
 39c:	30 e0       	ldi	r19, 0x00	; 0
 39e:	24 27       	eor	r18, r20
 3a0:	35 27       	eor	r19, r21
 3a2:	80 e0       	ldi	r24, 0x00	; 0
		for (i=0; i<8; i++)
		{
			temp=crc;
			crc>>=1;
 3a4:	a9 01       	movw	r20, r18
 3a6:	56 95       	lsr	r21
 3a8:	47 95       	ror	r20
			if(temp & 0x0001) crc^=0xa001;
 3aa:	20 ff       	sbrs	r18, 0
 3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <crc16_modbus+0x30>
 3ae:	4c 27       	eor	r20, r28
 3b0:	5d 27       	eor	r21, r29
	for (pos=0; pos<=len; pos++)
	{
		temp=buf[pos];
		temp&=0x00ff;
		crc ^=temp;
		for (i=0; i<8; i++)
 3b2:	8f 5f       	subi	r24, 0xFF	; 255
 3b4:	88 30       	cpi	r24, 0x08	; 8
 3b6:	11 f0       	breq	.+4      	; 0x3bc <crc16_modbus+0x3a>
 3b8:	9a 01       	movw	r18, r20
 3ba:	f4 cf       	rjmp	.-24     	; 0x3a4 <crc16_modbus+0x22>
//**********************************************************************************
unsigned int crc16_modbus(unsigned char *buf,unsigned char len)
{
	unsigned int crc=0xffff,temp;
	unsigned char pos,i;
	for (pos=0; pos<=len; pos++)
 3bc:	7f 5f       	subi	r23, 0xFF	; 255
 3be:	67 17       	cp	r22, r23
 3c0:	40 f7       	brcc	.-48     	; 0x392 <crc16_modbus+0x10>
			crc>>=1;
			if(temp & 0x0001) crc^=0xa001;
		}
	}
	return crc;
}
 3c2:	ca 01       	movw	r24, r20
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <__vector_7>:
{
volatile unsigned char tb:1; //флаг блокировки
} flag_tim2;
//*********************************************************************
ISR(TIMER2_COMPA_vect)
{
 3ca:	1f 92       	push	r1
 3cc:	0f 92       	push	r0
 3ce:	0f b6       	in	r0, 0x3f	; 63
 3d0:	0f 92       	push	r0
 3d2:	11 24       	eor	r1, r1
 3d4:	2f 93       	push	r18
 3d6:	3f 93       	push	r19
 3d8:	4f 93       	push	r20
 3da:	5f 93       	push	r21
 3dc:	6f 93       	push	r22
 3de:	7f 93       	push	r23
 3e0:	8f 93       	push	r24
 3e2:	9f 93       	push	r25
 3e4:	af 93       	push	r26
 3e6:	bf 93       	push	r27
 3e8:	ef 93       	push	r30
 3ea:	ff 93       	push	r31
switch (code)
 3ec:	80 91 00 01 	lds	r24, 0x0100
 3f0:	83 33       	cpi	r24, 0x33	; 51
 3f2:	19 f0       	breq	.+6      	; 0x3fa <__vector_7+0x30>
 3f4:	89 39       	cpi	r24, 0x99	; 153
 3f6:	41 f4       	brne	.+16     	; 0x408 <__vector_7+0x3e>
 3f8:	02 c0       	rjmp	.+4      	; 0x3fe <__vector_7+0x34>
{
	case 0x33:
	{
		Init_dat_r33();
 3fa:	97 de       	rcall	.-722    	; 0x12a <Init_dat_r33>
 3fc:	05 c0       	rjmp	.+10     	; 0x408 <__vector_7+0x3e>
		break;
	}
	case 0x99: // игра пассивными ракетками.
	{
		EIMSK=(1<<INT0);
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	8d bb       	out	0x1d, r24	; 29
		EIFR=0;	
 402:	1c ba       	out	0x1c, r1	; 28
		TCCR2B=0; //стоп таймер
 404:	10 92 b1 00 	sts	0x00B1, r1
		break;
	}
}	
}
 408:	ff 91       	pop	r31
 40a:	ef 91       	pop	r30
 40c:	bf 91       	pop	r27
 40e:	af 91       	pop	r26
 410:	9f 91       	pop	r25
 412:	8f 91       	pop	r24
 414:	7f 91       	pop	r23
 416:	6f 91       	pop	r22
 418:	5f 91       	pop	r21
 41a:	4f 91       	pop	r20
 41c:	3f 91       	pop	r19
 41e:	2f 91       	pop	r18
 420:	0f 90       	pop	r0
 422:	0f be       	out	0x3f, r0	; 63
 424:	0f 90       	pop	r0
 426:	1f 90       	pop	r1
 428:	18 95       	reti

0000042a <__vector_2>:
}crc;
//***********************************************************************
volatile unsigned int tim1; // значение таймера.
//***********************************************************************
ISR(INT1_vect) // прерывание по int1 удар 0 ракеткой.
{
 42a:	1f 92       	push	r1
 42c:	0f 92       	push	r0
 42e:	0f b6       	in	r0, 0x3f	; 63
 430:	0f 92       	push	r0
 432:	11 24       	eor	r1, r1
 434:	2f 93       	push	r18
 436:	3f 93       	push	r19
 438:	4f 93       	push	r20
 43a:	5f 93       	push	r21
 43c:	6f 93       	push	r22
 43e:	7f 93       	push	r23
 440:	8f 93       	push	r24
 442:	9f 93       	push	r25
 444:	af 93       	push	r26
 446:	bf 93       	push	r27
 448:	ef 93       	push	r30
 44a:	ff 93       	push	r31
	switch(code)
 44c:	80 91 00 01 	lds	r24, 0x0100
 450:	83 33       	cpi	r24, 0x33	; 51
 452:	51 f4       	brne	.+20     	; 0x468 <__vector_2+0x3e>
	{
		case 0x33:  // тест датчиков и ракеток
		{
			Buf_out[2]=0x21;	
 454:	81 e2       	ldi	r24, 0x21	; 33
 456:	80 93 0f 01 	sts	0x010F, r24
			Buf_out[5]=0x4A;
 45a:	8a e4       	ldi	r24, 0x4A	; 74
 45c:	80 93 12 01 	sts	0x0112, r24
			Buf_out[6]=0x70;
 460:	80 e7       	ldi	r24, 0x70	; 112
 462:	80 93 13 01 	sts	0x0113, r24
			Enable_TX();
 466:	98 de       	rcall	.-720    	; 0x198 <Enable_TX>
			break;
		}
	}
	Enable_T2_StopInt();
 468:	30 d1       	rcall	.+608    	; 0x6ca <Enable_T2_StopInt>
}
 46a:	ff 91       	pop	r31
 46c:	ef 91       	pop	r30
 46e:	bf 91       	pop	r27
 470:	af 91       	pop	r26
 472:	9f 91       	pop	r25
 474:	8f 91       	pop	r24
 476:	7f 91       	pop	r23
 478:	6f 91       	pop	r22
 47a:	5f 91       	pop	r21
 47c:	4f 91       	pop	r20
 47e:	3f 91       	pop	r19
 480:	2f 91       	pop	r18
 482:	0f 90       	pop	r0
 484:	0f be       	out	0x3f, r0	; 63
 486:	0f 90       	pop	r0
 488:	1f 90       	pop	r1
 48a:	18 95       	reti

0000048c <__vector_1>:
//************************************************************************
ISR(INT0_vect) // прерывание по int0
{
 48c:	1f 92       	push	r1
 48e:	0f 92       	push	r0
 490:	0f b6       	in	r0, 0x3f	; 63
 492:	0f 92       	push	r0
 494:	11 24       	eor	r1, r1
 496:	2f 93       	push	r18
 498:	3f 93       	push	r19
 49a:	4f 93       	push	r20
 49c:	5f 93       	push	r21
 49e:	6f 93       	push	r22
 4a0:	7f 93       	push	r23
 4a2:	8f 93       	push	r24
 4a4:	9f 93       	push	r25
 4a6:	af 93       	push	r26
 4a8:	bf 93       	push	r27
 4aa:	ef 93       	push	r30
 4ac:	ff 93       	push	r31
	switch(code)
 4ae:	80 91 00 01 	lds	r24, 0x0100
 4b2:	83 33       	cpi	r24, 0x33	; 51
 4b4:	19 f0       	breq	.+6      	; 0x4bc <__vector_1+0x30>
 4b6:	89 39       	cpi	r24, 0x99	; 153
 4b8:	91 f4       	brne	.+36     	; 0x4de <__vector_1+0x52>
 4ba:	08 c0       	rjmp	.+16     	; 0x4cc <__vector_1+0x40>
	{
		case 0x33:  // тест датчиков и ракеток
		{
			Buf_out[2]=0x30;	
 4bc:	80 e3       	ldi	r24, 0x30	; 48
 4be:	80 93 0f 01 	sts	0x010F, r24
			Buf_out[5]=0x4f;
 4c2:	8f e4       	ldi	r24, 0x4F	; 79
 4c4:	80 93 12 01 	sts	0x0112, r24
			Buf_out[6]=0x20;
 4c8:	80 e2       	ldi	r24, 0x20	; 32
 4ca:	07 c0       	rjmp	.+14     	; 0x4da <__vector_1+0x4e>
			break;
		}
		case 0x99:
		{
			Buf_out[2]=0x30;
 4cc:	80 e3       	ldi	r24, 0x30	; 48
 4ce:	80 93 0f 01 	sts	0x010F, r24
			Buf_out[5]=0x57;
 4d2:	87 e5       	ldi	r24, 0x57	; 87
 4d4:	80 93 12 01 	sts	0x0112, r24
			Buf_out[6]=0x38;
 4d8:	88 e3       	ldi	r24, 0x38	; 56
 4da:	80 93 13 01 	sts	0x0113, r24
			break;
		}
	}
	Enable_TX();
 4de:	5c de       	rcall	.-840    	; 0x198 <Enable_TX>
	Enable_T2_StopInt();
 4e0:	f4 d0       	rcall	.+488    	; 0x6ca <Enable_T2_StopInt>
}
 4e2:	ff 91       	pop	r31
 4e4:	ef 91       	pop	r30
 4e6:	bf 91       	pop	r27
 4e8:	af 91       	pop	r26
 4ea:	9f 91       	pop	r25
 4ec:	8f 91       	pop	r24
 4ee:	7f 91       	pop	r23
 4f0:	6f 91       	pop	r22
 4f2:	5f 91       	pop	r21
 4f4:	4f 91       	pop	r20
 4f6:	3f 91       	pop	r19
 4f8:	2f 91       	pop	r18
 4fa:	0f 90       	pop	r0
 4fc:	0f be       	out	0x3f, r0	; 63
 4fe:	0f 90       	pop	r0
 500:	1f 90       	pop	r1
 502:	18 95       	reti

00000504 <__vector_3>:

// обработка датчиков 1,6,7
ISR(PCINT0_vect)
{
 504:	1f 92       	push	r1
 506:	0f 92       	push	r0
 508:	0f b6       	in	r0, 0x3f	; 63
 50a:	0f 92       	push	r0
 50c:	11 24       	eor	r1, r1
 50e:	2f 93       	push	r18
 510:	3f 93       	push	r19
 512:	4f 93       	push	r20
 514:	5f 93       	push	r21
 516:	6f 93       	push	r22
 518:	7f 93       	push	r23
 51a:	8f 93       	push	r24
 51c:	9f 93       	push	r25
 51e:	af 93       	push	r26
 520:	bf 93       	push	r27
 522:	ef 93       	push	r30
 524:	ff 93       	push	r31
	unsigned char pin;
	pin=PINB; // считываем порт.
 526:	93 b1       	in	r25, 0x03	; 3
	pin=(~pin&0x07);
	switch (code)
 528:	80 91 00 01 	lds	r24, 0x0100
 52c:	83 33       	cpi	r24, 0x33	; 51
 52e:	11 f5       	brne	.+68     	; 0x574 <__vector_3+0x70>
// обработка датчиков 1,6,7
ISR(PCINT0_vect)
{
	unsigned char pin;
	pin=PINB; // считываем порт.
	pin=(~pin&0x07);
 530:	89 2f       	mov	r24, r25
 532:	80 95       	com	r24
	switch (code)
	{
		case 0x33: // тест датчиков и ракеток
		{
			switch (pin)
 534:	87 70       	andi	r24, 0x07	; 7
 536:	82 30       	cpi	r24, 0x02	; 2
 538:	61 f0       	breq	.+24     	; 0x552 <__vector_3+0x4e>
 53a:	84 30       	cpi	r24, 0x04	; 4
 53c:	91 f0       	breq	.+36     	; 0x562 <__vector_3+0x5e>
 53e:	81 30       	cpi	r24, 0x01	; 1
 540:	d9 f4       	brne	.+54     	; 0x578 <__vector_3+0x74>
			{
				case 0x01: // сработал 1 датчик
				{
					Buf_out[2]=0x31;
 542:	81 e3       	ldi	r24, 0x31	; 49
 544:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x8F;
 548:	8f e8       	ldi	r24, 0x8F	; 143
 54a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0x71;
 54e:	81 e7       	ldi	r24, 0x71	; 113
 550:	0f c0       	rjmp	.+30     	; 0x570 <__vector_3+0x6c>
					break;
				}	
				case 0x02: // сработал 6 датчик
				{
					
					Buf_out[2]=0x36;
 552:	86 e3       	ldi	r24, 0x36	; 54
 554:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x4E;
 558:	8e e4       	ldi	r24, 0x4E	; 78
 55a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0xC0;
 55e:	80 ec       	ldi	r24, 0xC0	; 192
 560:	07 c0       	rjmp	.+14     	; 0x570 <__vector_3+0x6c>
					break;
				}
				case 0x04: // сработал 7 датчик.
				{
					Buf_out[2]=0x37;
 562:	87 e3       	ldi	r24, 0x37	; 55
 564:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x8E;
 568:	8e e8       	ldi	r24, 0x8E	; 142
 56a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0x91;
 56e:	81 e9       	ldi	r24, 0x91	; 145
 570:	80 93 13 01 	sts	0x0113, r24
					return;
				}
			}
		}
	}
	Enable_TX();
 574:	11 de       	rcall	.-990    	; 0x198 <Enable_TX>
	// отключаем прерывания время антидребезга
	Enable_T2_StopInt();
 576:	a9 d0       	rcall	.+338    	; 0x6ca <Enable_T2_StopInt>
}
 578:	ff 91       	pop	r31
 57a:	ef 91       	pop	r30
 57c:	bf 91       	pop	r27
 57e:	af 91       	pop	r26
 580:	9f 91       	pop	r25
 582:	8f 91       	pop	r24
 584:	7f 91       	pop	r23
 586:	6f 91       	pop	r22
 588:	5f 91       	pop	r21
 58a:	4f 91       	pop	r20
 58c:	3f 91       	pop	r19
 58e:	2f 91       	pop	r18
 590:	0f 90       	pop	r0
 592:	0f be       	out	0x3f, r0	; 63
 594:	0f 90       	pop	r0
 596:	1f 90       	pop	r1
 598:	18 95       	reti

0000059a <__vector_4>:
/// обработка датчиков 2,5,8
ISR(PCINT1_vect)
{
 59a:	1f 92       	push	r1
 59c:	0f 92       	push	r0
 59e:	0f b6       	in	r0, 0x3f	; 63
 5a0:	0f 92       	push	r0
 5a2:	11 24       	eor	r1, r1
 5a4:	2f 93       	push	r18
 5a6:	3f 93       	push	r19
 5a8:	4f 93       	push	r20
 5aa:	5f 93       	push	r21
 5ac:	6f 93       	push	r22
 5ae:	7f 93       	push	r23
 5b0:	8f 93       	push	r24
 5b2:	9f 93       	push	r25
 5b4:	af 93       	push	r26
 5b6:	bf 93       	push	r27
 5b8:	ef 93       	push	r30
 5ba:	ff 93       	push	r31
	unsigned char pin;
	pin=PINC; // считываем порт.
 5bc:	96 b1       	in	r25, 0x06	; 6
	pin=(~pin&0x07);
	switch (code)
 5be:	80 91 00 01 	lds	r24, 0x0100
 5c2:	83 33       	cpi	r24, 0x33	; 51
 5c4:	21 f5       	brne	.+72     	; 0x60e <__vector_4+0x74>
/// обработка датчиков 2,5,8
ISR(PCINT1_vect)
{
	unsigned char pin;
	pin=PINC; // считываем порт.
	pin=(~pin&0x07);
 5c6:	89 2f       	mov	r24, r25
 5c8:	80 95       	com	r24
	switch (code)
	{
		case 0x33: // тест датчиков и ракеток
		{
			switch (pin)
 5ca:	87 70       	andi	r24, 0x07	; 7
 5cc:	82 30       	cpi	r24, 0x02	; 2
 5ce:	61 f0       	breq	.+24     	; 0x5e8 <__vector_4+0x4e>
 5d0:	84 30       	cpi	r24, 0x04	; 4
 5d2:	a1 f0       	breq	.+40     	; 0x5fc <__vector_4+0x62>
 5d4:	81 30       	cpi	r24, 0x01	; 1
 5d6:	e9 f4       	brne	.+58     	; 0x612 <__vector_4+0x78>
			{
				case 0x01: // сработал 2 датчик
				{
					Buf_out[2]=0x32;
 5d8:	82 e3       	ldi	r24, 0x32	; 50
 5da:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x8F;
 5de:	8f e8       	ldi	r24, 0x8F	; 143
 5e0:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0x81;
 5e4:	81 e8       	ldi	r24, 0x81	; 129
 5e6:	11 c0       	rjmp	.+34     	; 0x60a <__vector_4+0x70>
					break;
				}	
				case 0x02: // сработал 5 датчик
				{
					
					Buf_out[5]=0x4E;
 5e8:	8e e4       	ldi	r24, 0x4E	; 78
 5ea:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0x30;
 5ee:	80 e3       	ldi	r24, 0x30	; 48
 5f0:	80 93 13 01 	sts	0x0113, r24
					Buf_out[2]=0x35;
 5f4:	85 e3       	ldi	r24, 0x35	; 53
 5f6:	80 93 0f 01 	sts	0x010F, r24
 5fa:	09 c0       	rjmp	.+18     	; 0x60e <__vector_4+0x74>
					break;
				}
				case 0x04: // сработал 8 датчик.
				{
					Buf_out[2]=0x38;
 5fc:	88 e3       	ldi	r24, 0x38	; 56
 5fe:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x8D;
 602:	8d e8       	ldi	r24, 0x8D	; 141
 604:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0xA1;
 608:	81 ea       	ldi	r24, 0xA1	; 161
 60a:	80 93 13 01 	sts	0x0113, r24
					return;
				}
			}
		}
	}
	Enable_TX();
 60e:	c4 dd       	rcall	.-1144   	; 0x198 <Enable_TX>
	// отключаем прерывания время антидребезга
	Enable_T2_StopInt();
 610:	5c d0       	rcall	.+184    	; 0x6ca <Enable_T2_StopInt>
}
 612:	ff 91       	pop	r31
 614:	ef 91       	pop	r30
 616:	bf 91       	pop	r27
 618:	af 91       	pop	r26
 61a:	9f 91       	pop	r25
 61c:	8f 91       	pop	r24
 61e:	7f 91       	pop	r23
 620:	6f 91       	pop	r22
 622:	5f 91       	pop	r21
 624:	4f 91       	pop	r20
 626:	3f 91       	pop	r19
 628:	2f 91       	pop	r18
 62a:	0f 90       	pop	r0
 62c:	0f be       	out	0x3f, r0	; 63
 62e:	0f 90       	pop	r0
 630:	1f 90       	pop	r1
 632:	18 95       	reti

00000634 <__vector_5>:
// обработка датчиков 3,4,9
ISR(PCINT2_vect)
{
 634:	1f 92       	push	r1
 636:	0f 92       	push	r0
 638:	0f b6       	in	r0, 0x3f	; 63
 63a:	0f 92       	push	r0
 63c:	11 24       	eor	r1, r1
 63e:	2f 93       	push	r18
 640:	3f 93       	push	r19
 642:	4f 93       	push	r20
 644:	5f 93       	push	r21
 646:	6f 93       	push	r22
 648:	7f 93       	push	r23
 64a:	8f 93       	push	r24
 64c:	9f 93       	push	r25
 64e:	af 93       	push	r26
 650:	bf 93       	push	r27
 652:	ef 93       	push	r30
 654:	ff 93       	push	r31
		unsigned char pin;
	pin=PIND; // считываем порт.
 656:	89 b1       	in	r24, 0x09	; 9
	pin=(~pin&0x70);
	pin>>=4;
	switch (code)
 658:	90 91 00 01 	lds	r25, 0x0100
 65c:	93 33       	cpi	r25, 0x33	; 51
 65e:	11 f5       	brne	.+68     	; 0x6a4 <__vector_5+0x70>
// обработка датчиков 3,4,9
ISR(PCINT2_vect)
{
		unsigned char pin;
	pin=PIND; // считываем порт.
	pin=(~pin&0x70);
 660:	80 95       	com	r24
 662:	80 77       	andi	r24, 0x70	; 112
	pin>>=4;
	switch (code)
	{
		case 0x33: // тест датчиков и ракеток
		{
			switch (pin)
 664:	82 95       	swap	r24
 666:	8f 70       	andi	r24, 0x0F	; 15
 668:	82 30       	cpi	r24, 0x02	; 2
 66a:	59 f0       	breq	.+22     	; 0x682 <__vector_5+0x4e>
 66c:	84 30       	cpi	r24, 0x04	; 4
 66e:	89 f0       	breq	.+34     	; 0x692 <__vector_5+0x5e>
 670:	81 30       	cpi	r24, 0x01	; 1
 672:	d1 f4       	brne	.+52     	; 0x6a8 <__vector_5+0x74>
			{
				case 0x01: // сработал 3 датчик
				{
					Buf_out[2]=0x33;
 674:	90 93 0f 01 	sts	0x010F, r25
					Buf_out[5]=0x4F;
 678:	8f e4       	ldi	r24, 0x4F	; 79
 67a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0xD0;
 67e:	80 ed       	ldi	r24, 0xD0	; 208
 680:	0f c0       	rjmp	.+30     	; 0x6a0 <__vector_5+0x6c>
					break;
				}	
				case 0x02: // сработал 4 датчик
				{
					Buf_out[2]=0x34;
 682:	84 e3       	ldi	r24, 0x34	; 52
 684:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x8E;
 688:	8e e8       	ldi	r24, 0x8E	; 142
 68a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0x61;
 68e:	81 e6       	ldi	r24, 0x61	; 97
 690:	07 c0       	rjmp	.+14     	; 0x6a0 <__vector_5+0x6c>
					break;
				}
				case 0x04: // сработал 9 датчик.
				{
					Buf_out[2]=0x39;
 692:	89 e3       	ldi	r24, 0x39	; 57
 694:	80 93 0f 01 	sts	0x010F, r24
					Buf_out[5]=0x4D;
 698:	8d e4       	ldi	r24, 0x4D	; 77
 69a:	80 93 12 01 	sts	0x0112, r24
					Buf_out[6]=0xF0;
 69e:	80 ef       	ldi	r24, 0xF0	; 240
 6a0:	80 93 13 01 	sts	0x0113, r24
					return;
				}
			}
		}
	}
	Enable_TX();
 6a4:	79 dd       	rcall	.-1294   	; 0x198 <Enable_TX>
// отключаем прерывания время антидребезга
	Enable_T2_StopInt();
 6a6:	11 d0       	rcall	.+34     	; 0x6ca <Enable_T2_StopInt>
}
 6a8:	ff 91       	pop	r31
 6aa:	ef 91       	pop	r30
 6ac:	bf 91       	pop	r27
 6ae:	af 91       	pop	r26
 6b0:	9f 91       	pop	r25
 6b2:	8f 91       	pop	r24
 6b4:	7f 91       	pop	r23
 6b6:	6f 91       	pop	r22
 6b8:	5f 91       	pop	r21
 6ba:	4f 91       	pop	r20
 6bc:	3f 91       	pop	r19
 6be:	2f 91       	pop	r18
 6c0:	0f 90       	pop	r0
 6c2:	0f be       	out	0x3f, r0	; 63
 6c4:	0f 90       	pop	r0
 6c6:	1f 90       	pop	r1
 6c8:	18 95       	reti

000006ca <Enable_T2_StopInt>:

void Enable_T2_StopInt(void) // запускаем таймер 2 и отключаем все датчики на время антидребезга.
{
	TIMSK2=0; 
 6ca:	e0 e7       	ldi	r30, 0x70	; 112
 6cc:	f0 e0       	ldi	r31, 0x00	; 0
 6ce:	10 82       	st	Z, r1
	GTCCR=0x02;
 6d0:	82 e0       	ldi	r24, 0x02	; 2
 6d2:	83 bd       	out	0x23, r24	; 35
	EIMSK=0;
 6d4:	1d ba       	out	0x1d, r1	; 29
	PCICR=0;
 6d6:	10 92 68 00 	sts	0x0068, r1
	TCNT2=0;
 6da:	10 92 b2 00 	sts	0x00B2, r1
	TIMSK2=0x02;
 6de:	80 83       	st	Z, r24
	TCCR2B=0x07;
 6e0:	87 e0       	ldi	r24, 0x07	; 7
 6e2:	80 93 b1 00 	sts	0x00B1, r24
}
 6e6:	08 95       	ret

000006e8 <_exit>:
 6e8:	f8 94       	cli

000006ea <__stop_program>:
 6ea:	ff cf       	rjmp	.-2      	; 0x6ea <__stop_program>
